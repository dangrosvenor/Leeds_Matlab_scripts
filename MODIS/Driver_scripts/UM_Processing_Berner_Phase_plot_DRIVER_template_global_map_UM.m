%Stripped down template for running plot_global_maps to produce a global
%map

%Data created using 
% UM_maps_generic_time_loop_RUN_v1_aerosol_Processing_May2017.m
% makes time means of the 2D fields (that were generated by calc_LWP_multi_UM.m

plot_type_Berner = 'plot_arrow_to_next'; %plots all of the arrows for the N*M blocks.
plot_type_Berner = 'plot_mean_arrow_to_next'; %Averages the arrows for 2d bins of the LWP-Nd phase space

y_axis = 'LWP';
%y_axis = 'BL height using RH50';

M=50;  %no. gridpoints (each one 1km, but may not be the same for all runs)
N=50;
%M=100; N=100;

rim_width = 100;

dt = 1; %hours - time step to calculate differences over.
t_start_average = 15; %Hours into run to start the averaging for the final overall plot

LWP_thresh=5; %g/m2 - threshold for cloud -

inormalise=1; %whether to normalise realative the domain mean for each time.=0 no normalisation, =1 (x-x_mean)/x_std_sev, =2 x-x_mean
ino_multiple_figs=1; %=1 to supress the figs for each time

savedir = '/home/disk/eos1/d.grosvenor/modis_work/plots_May2017/';

UM_cases = '12th Nov case, as of Feb 2017 processing runs PLOTS multi-dirUM';
%UM_cases = '12th Nov case, as of Feb 2017 processing runs PLOTS multi-dirUM Processing OFF';


%set below
%VAR_NAME_STR = 'BL height using qL';

UM_datatype = '2D time mean';
UM_datatype = 'All data';

switch inormalise
    case 1
        %    Xbins_DRIVER = [0:0.1:5.1]; ichoose_Ybins=1;
        %    Ybins_DRIVER = [0:0.1:5.2]; ichoose_Xbins=1;
        Xbins_DRIVER = [-5:0.5:5.5]; ichoose_Xbins=1;
        Ybins_DRIVER = [-5:0.5:5]; ichoose_Ybins=1;
    case 2
        Xbins_DRIVER = [-150:10:100]; ichoose_Xbins=1;
        Ybins_DRIVER = [-100:30:200]; ichoose_Ybins=1;        
    otherwise
        Xbins_DRIVER = [0:10:500]; ichoose_Xbins=1;
        switch y_axis
            case 'LWP'
                Ybins_DRIVER = [0:30:600]; ichoose_Ybins=1;
            case 'BL height using RH50'
                Ybins_DRIVER = [850:35:1600]; ichoose_Ybins=1;
        end
end


%Set the batch of UM runs to loop through
UM_case_select_RUN
%% Loop through the different UM runs
for idat_UM=1:1 %length(fileUM)
    
    if iscell(dirUM)==1
        dirUM_i = dirUM{idat_UM};
    else
        dirUM_i = dirUM;        
    end
    
    VAR_NAME_STR = 'LWP'; [LWP,file_UM] = UM_get_filename_for_var(dirUM_i,fileUM{idat_UM},VAR_NAME_STR,'lwp',UM_datatype);
    
    switch y_axis
        case 'LWP'
            ydat = LWP;
            y_axis_lab = 'LWP'
        case 'BL height using RH50'
            VAR_NAME_STR = 'BL height using RH50'; [ydat,file_UM] = UM_get_filename_for_var(dirUM_i,fileUM{idat_UM},VAR_NAME_STR,'zi',UM_datatype);
            y_axis_lab = 'z_i';
    end

VAR_NAME_STR = 'Nd'; [Nd,file_UM] = UM_get_filename_for_var(dirUM_i,fileUM{idat_UM},VAR_NAME_STR,'Nd',UM_datatype);    


load(file_UM,'time_matlab');
    
    
    


% Set some stuff

%Define lat and lon grids
% filename = '/home/disk/eos8/d.grosvenor/mat_files_various/SAVED_ann2008_CF_0.8_meanCTT_173_meanCTH_3.2km_SZA_65.mat';
% load(filename,'MLAT','MLON');
gcm_str_DRIVER='UM';  %N.B. - have to set it to this and not another name - doesn't work if do (code would need changing)
% [gcm_Plon2D_UM,gcm_Plat2D_UM] = meshgrid(MLON,MLAT);
% [gcm_Plon2D_edges_UM,gcm_Plat2D_edges_UM] = get_edges_lat_lon(gcm_Plon2D_UM,gcm_Plat2D_UM);
load(file_UM,'gcm_Plon2D_UM','gcm_Plat2D_UM','gcm_Plon2D_edges_UM','gcm_Plat2D_edges_UM');


daynum_timeseries3_UM = 1; %[1:length(time)];
gcm_time_UTC_UM = 1; %[1:length(time)];


%% Calculate stuff for the Berner calculations
nT = size(ydat.dat,1);



dt_data = (time_matlab(2)-time_matlab(1) )*24; %frequency of data time output

dt_ind = floor(dt / dt_data + 0.001 );
dt_actual = dt_data*dt_ind;

Nd.dat(isnan(Nd.dat)) = 0;  %N.B there is an implicit min of 5 g/m2 since only did Nd calc when LWP>=5 g/m2 - so remove this for now
inot_cloud = find(LWP.dat<LWP_thresh);
ydat.dat(inot_cloud)=NaN;
Nd.dat(inot_cloud)=NaN;

ydat.dat = ydat.dat(:,rim_width:end-rim_width-1,rim_width:end-rim_width-1);
LWP.dat = LWP.dat(:,rim_width:end-rim_width-1,rim_width:end-rim_width-1);
Nd.dat = Nd.dat(:,rim_width:end-rim_width-1,rim_width:end-rim_width-1);

%Loop through all times doing coarse graining - will loop again later for
%the plotting
%First time is all zeros for Nd, so ignore that - although the first entry
%will stil exist in the final arrays
for it=[2:dt_ind:nT]

    %Coarse grain the data into patches which are larger than the motion
    %expected in time dt, so that we are essentially considering a
    %stationary box
    
    % With wind speed of 5 m/s is 18 km/hr. So would want boxes of around
    % 100km or so perhaps. This gives 5x5 boxes - maybe go a bit smaller?
    %dlat_target = 0.5;
    %dlon_target = 0.5;
    

    
    %d=diff(gcm_Plat2D_UM,[],1);
    %dlat_UM = meanNoNan(meanNoNan(d,1),1);
    %N = ceil(abs(dlat_target/dlat_UM));
    
    
    %d=diff(gcm_Plon2D_UM,[],2);
    %dlon_UM = meanNoNan(meanNoNan(d,1),1);
    %M = ceil(abs(dlon_target/dlon_UM));
 
    
    if it==2
        gcm_Plat2D_UM = reduce_matrix_subsample_mean(gcm_Plat2D_UM(rim_width:end-rim_width-1,rim_width:end-rim_width-1),N,M);
        gcm_Plon2D_UM = reduce_matrix_subsample_mean(gcm_Plon2D_UM(rim_width:end-rim_width-1,rim_width:end-rim_width-1),N,M);
        %Work out the cell edges (as halfway between the centres)
        [gcm_Plat2D_edges_UM, gcm_Plon2D_edges_UM]=get_edges_lat_lon(gcm_Plat2D_UM,gcm_Plon2D_UM);
        
        LWP2 = NaN * ones([nT size(gcm_Plon2D_UM)]);
        ydat2 = NaN * ones([nT size(gcm_Plon2D_UM)]);        
        Nd2 = NaN * ones([nT size(gcm_Plon2D_UM)]);
    end
       
    
    LWP2(it,:,:) = reduce_matrix_subsample_mean(squeeze(LWP.dat(it,:,:)),N,M);
    ydat2(it,:,:) = reduce_matrix_subsample_mean(squeeze(ydat.dat(it,:,:)),N,M);    
    Nd2(it,:,:) = reduce_matrix_subsample_mean(squeeze(Nd.dat(it,:,:)),N,M);        
       
end

%Domain means for normalizing
%LWP_mean = meanNoNan(meanNoNan(LWP2,2),2);
%Nd_mean = meanNoNan(meanNoNan(Nd2,2),2);
%Nd_std_dev = std(Nd2(:,:),0,2);
%LWP_std_dev = std(LWP2(:,:),0,2);

[LWP_mean,nnums,LWP_std_dev]=meanNoNan(LWP2(:,:),2);
[ydat_mean,nnums,ydat_std_dev]=meanNoNan(ydat2(:,:),2);
[Nd_mean,nnums,Nd_std_dev]=meanNoNan(Nd2(:,:),2);

switch inormalise
    case 1
        %LWP_mean2 = ( LWP_mean(1:end-1) + LWP_mean(2:end) ) /2;
        %Nd_mean2 = ( Nd_mean(1:end-1) + Nd_mean(2:end) ) /2;

        LWP_mean2 = ( LWP_mean(1:end) );
        ydat_mean2 = ( ydat_mean(1:end) );        
        Nd_mean2 = ( Nd_mean(1:end) );
        
        LWP_std_dev2 = LWP_std_dev(1:end); 
        ydat_std_dev2 = ydat_std_dev(1:end);         
        Nd_std_dev2 = Nd_std_dev(1:end);

    case 2 %Remove mean, but don't divide by std dev
        
        LWP_mean2 = ( LWP_mean(1:end) );
        ydat_mean2 = ( ydat_mean(1:end) );
        Nd_mean2 = ( Nd_mean(1:end) );
        
        LWP_std_dev2  = ones( size(LWP_mean(1:end)) );
        ydat_std_dev2  = ones( size(ydat_mean(1:end)) );        
        Nd_std_dev2  = ones( size(LWP_mean(1:end)) );


    otherwise
        LWP_mean2 = ones( size(LWP_mean(1:end)) );
        ydat_mean2 = ones( size(LWP_mean(1:end)) );        
        Nd_mean2 = ones( size(LWP_mean(1:end)) );
        LWP_std_dev2  = ones( size(LWP_mean(1:end)) );
        ydat_std_dev2  = ones( size(LWP_mean(1:end)) );        
        Nd_std_dev2  = ones( size(LWP_mean(1:end)) );
end

LWP_mean3 = repmat(LWP_mean2,[1 size(gcm_Plon2D_UM)]);
ydat_mean3 = repmat(ydat_mean2,[1 size(gcm_Plon2D_UM)]);
Nd_mean3 = repmat(Nd_mean2,[1 size(gcm_Plon2D_UM)]);
LWP_std_dev3 = repmat(LWP_std_dev2,[1 size(gcm_Plon2D_UM)]);
ydat_std_dev3 = repmat(ydat_std_dev2,[1 size(gcm_Plon2D_UM)]);
Nd_std_dev3 = repmat(Nd_std_dev2,[1 size(gcm_Plon2D_UM)]);

%Make into a standard normalised variable (x-x_mean)/std_dev
LWP3 = (LWP2 - LWP_mean3) ./ LWP_std_dev3;
ydat3 = (ydat2 - ydat_mean3) ./ ydat_std_dev3;
Nd3 = (Nd2 - Nd_mean3) ./ Nd_std_dev3;

%calculate changes relative to the mean
%dLWP = diff(LWP2,1) ./ LWP_mean3;
%dNd = diff(Nd2,1) ./ Nd_mean3;

dLWP = diff(LWP3,1);
dydat = diff(ydat3,1);
dNd = diff(Nd3,1);


%% Loop over the times required and plot phase diagram

clear dydat_N dydat_mean dNd_N dNd_mean histo2D
%First time is all zeros for Nd, so ignore that - although the first entry
%will stil exist in the final arrays
for it_Berner=[2:dt_ind:nT-dt_ind]
    
%     if ino_multiple_figs==0
%         hf = figure
%     else
%         hf = figure('visible','off');
%     end

    
    switch plot_type_Berner
        case 'plot_mean_arrow_to_next'
            
            X_driver = Nd3(it_Berner,:,:);  %
            Y_driver = ydat3(it_Berner,:,:);
            Z_driver = dydat(it_Berner,:,:);

            noplot=1;           
            DRIVER_Berner_phase_diagram_2D_mean
            %close(gcf);
            dydat_N(it_Berner,:,:) = N2D; %2d histogram for ydat vs Nd
            dydat_mean(it_Berner,:,:) = qh;
            
            Z_driver = dNd(it_Berner,:,:);
            noplot=1;
            DRIVER_Berner_phase_diagram_2D_mean
            %close(gcf);
            dNd_N(it_Berner,:,:) = N2D; %2d histogram for ydat vs Nd
            dNd_mean(it_Berner,:,:) = qh;
                                    
            
            %Plot the middle of the 2d bin in filled colour
            it2=it_Berner;
            nX=length(mid_Xbins);
            nY=length(mid_Ybins);      
            inan=find(N2D==0);
            plot_dat_01 = (repmat(mid_Xbins,[nY 1]))';
            plot_dat_02 = repmat(mid_Ybins,[nX 1]);
            plot_dat_01(inan)=NaN;

            plot_dat_X = plot_dat_01(:);
            plot_dat_Y = plot_dat_02(:);
            
            %Do the histgram plot - will plot arrows on top of this
            if ino_multiple_figs==1
                noplot=1;
            else
                noplot=0;
            end 
            DRIVER_Berner_phase_2D_PDF_02
            histo2D(it_Berner,:,:) = qh(1:end-1,1:end-1)'; %should be the same as dydat_N or dNd_N
            
            if ino_multiple_figs==0
                %plot the initial point
                plot(plot_dat_X,plot_dat_Y,'ko','markerfacecolor','k'); hold on

                %Plot connecting line to the next time step (arrow for mean
                %vector)
                %The 2nd points on the line (first ones will remain the same)
                plot_dat_01 = plot_dat_01 + ( squeeze( dNd_mean(it_Berner,1:end-1,1:end-1) ) )';
                plot_dat_02 = plot_dat_02 + ( squeeze( dydat_mean(it_Berner,1:end-1,1:end-1) ) )';
                plot_dat_01(inan)=NaN;

                plot_dat_X = cat(2,plot_dat_X,plot_dat_01(:));
                plot_dat_Y = cat(2,plot_dat_Y,plot_dat_02(:));

                %plot the connecting line
                plot(plot_dat_X',plot_dat_Y','w-');
                %plot the end point
                plot(plot_dat_01(:),plot_dat_02(:),'w^');
            end
            '';
%            if ino_multiple_figs==1
%                close(gcf);
%            end
            
%            set(gca,'xlim',[0 1.5]);
%            set(gca,'ylim',[0 3.5]);
            
            
        case 'plot_arrow_to_next'
            %Plot first normalised data point
            it2=it_Berner;
            plot_dat_01 = ydat2(it2,:,:);
            plot_dat_02 = Nd2(it2,:,:);


            plot_dat_Y = plot_dat_01(:)/ydat_mean2(it2);
            plot_dat_X = plot_dat_02(:)/Nd_mean2(it2);

            plot(plot_dat_X,plot_dat_Y,'bo','markerfacecolor','b'); hold on

            %Plot first next normalised data point
            it2=it_Berner+dt_ind;
            plot_dat_01 = ydat2(it2,:,:)/ydat_mean2(it_Berner);
            plot_dat_02 = Nd2(it2,:,:)/Nd_mean2(it_Berner);
            %plot(plot_dat_01(:)/ydat_mean2(it2),plot_dat_02(:)/Nd_mean2(it2),'ko');

            plot_dat_Y = cat(2,plot_dat_Y,plot_dat_01(:));
            plot_dat_X = cat(2,plot_dat_X,plot_dat_02(:));

            plot(plot_dat_X',plot_dat_Y','bo-');



    end
    
     if inormalise==1
        %set(gca,'xlim',[-10 10]);
        %set(gca,'ylim',[-10 10]);
    else
        %set(gca,'xlim',[0 300]);
        %set(gca,'ylim',[0 300]);
    end
    
    if ino_multiple_figs==0
        ylabel([y_axis_lab ' (normalised)']);
        xlabel('N_d (normalised)');
        savename = [y_axis_lab ' vs Nd, ' fileUM{idat_UM}(1:7) ', ' datestr(time_matlab(it_Berner)) ', dt=' num2str(dt_actual) ', LWP thresh = ' num2str(LWP_thresh), ', M=' num2str(M) ', N=' num2str(N)];
        title(savename);

        saveas_ps_fig_emf(gcf,[savedir savename],'',0,1,0,'',[],1);

    end
    
   
    
end

%% Do overall average vector
%Time indices to include for this
clear it_av2 it_title N_min2

N_min_ALL = 5;
N_min_low = 1;


time_into_run = ( time_matlab - time_matlab(1) ) *24; %hours
it_start = find(time_into_run >= t_start_average);

i=1;
%All selected times
it_all = it_start(1):size(LWP3,1)-1;
lwp_all = LWP_mean(it_all);
it_av2{i} = [it_all]; N_min2(i)=N_min_ALL; it_title{i} = [datestr(time_matlab(it_all(1))) ' to ' datestr(time_matlab(it_all(end)))]; i=i+1;

[time_mean_lwp,nnums,time_std_lwp] = meanNoNan(lwp_all,1);
prcs = prctile(lwp_all,[33 67]);
lwp33=prcs(1); lwp67=prcs(2);

% Low LWP times
%thresh = [-9e9 time_mean_lwp - time_std_lwp];
thresh = [-9e9 lwp33];
it = find(lwp_all >= thresh(1) & lwp_all < thresh(2) );
it_av2{i} = it_all(it); N_min2(i)=N_min_low; it_title{i} = 'Low LWP periods'; i=i+1;

% Intermediate LWP times
%thresh = [time_mean_lwp-time_std_lwp time_mean_lwp+time_std_lwp];
thresh = [lwp33 lwp67];
it = find(lwp_all >= thresh(1) & lwp_all < thresh(2) );
it_av2{i} = [it_all(it)]; N_min2(i)=N_min_low; it_title{i} = 'Intermediate LWP periods'; i=i+1;

% High LWP times
%thresh = [time_mean_lwp + time_std_lwp 9e9];
thresh = [lwp67 9e9];
it = find(lwp_all >= thresh(1) & lwp_all < thresh(2) );
it_av2{i} = [it_all(it)]; N_min2(i)=N_min_low; it_title{i} = 'High LWP periods'; i=i+1;

for it_periods = 1:length(it_av2)
    
    it_av = it_av2{it_periods};

dydat_mean_overall = meanNoNan ( dydat_N(it_av,:,:) .* permute(dydat_mean(it_av,1:end-1,1:end-1),[1 3 2]) , 1, 'sum' ) ./  meanNoNan ( dydat_N(it_av,:,:) , 1, 'sum' );
dNd_mean_overall = meanNoNan ( dNd_N(it_av,:,:) .* permute(dNd_mean(it_av,1:end-1,1:end-1),[1 3 2]) , 1, 'sum' ) ./  meanNoNan ( dNd_N(it_av,:,:) , 1, 'sum' );
N_overall = meanNoNan ( dydat_N(it_av,:,:) , 1, 'sum' );
%N_overall2 = meanNoNan ( dNd_N(it_av,:,:) , 1, 'sum' ); %total numbers are
%the same for ydat as for Nd

%Need to do a 2D histgram of N_overall

scrsz=get(0,'ScreenSize');
posit=[9 50 scrsz(3)/1.46 scrsz(4)/1.26];
hf=figure('position',posit,'name',figlab);
%N_overall2  = N_overall;
%N_overall2(end+1,:) = NaN;

dpcolor(Xbins,Ybins,(squeeze(N_overall))' ); shading flat; colorbar
hold on

            %Plot the middle of the 2d bin in filled colour       
            N_min = N_min2(it_periods);
            nX=length(mid_Xbins);
            nY=length(mid_Ybins);      
            inan=find(N_overall<N_min);
            
            plot_dat_01 = (repmat(mid_Xbins,[nY 1]))';
            plot_dat_02 = repmat(mid_Ybins,[nX 1]);
            plot_dat_01(inan)=NaN;

            plot_dat_X = plot_dat_01(:);
            plot_dat_Y = plot_dat_02(:);
            
            plot_dat_X_start = plot_dat_X;
            plot_dat_Y_start = plot_dat_Y; 
            
            dX = squeeze( dNd_mean_overall(:) );
            dY = squeeze( dydat_mean_overall(:) );       
            
            quiver(plot_dat_X_start,plot_dat_Y_start,dX,dY,0,'w');
            
%             
%             %Do the histgram plot - will plot arrows on top of this
%             %DRIVER_Berner_phase_2D_PDF_02
% 
%             %plot the initial point
             plot(plot_dat_X,plot_dat_Y,'ko','markerfacecolor','k'); hold on
% 
%             %Plot connecting line to the next time step (arrow for mean
%             %vector)
%             %The 2nd points on the line (first ones will remain the same)
%             plot_dat_01 = plot_dat_01 + ( squeeze( dNd_mean_overall ) );
%             plot_dat_02 = plot_dat_02 + ( squeeze( dydat_mean_overall) );           
%             plot_dat_01(inan)=NaN;
%             
%             plot_dat_X = cat(2,plot_dat_X,plot_dat_01(:));
%             plot_dat_Y = cat(2,plot_dat_Y,plot_dat_02(:));
% 
%             %plot the connecting line
%             plot(plot_dat_X',plot_dat_Y','w-');
%             %plot the end point
%             plot(plot_dat_01(:),plot_dat_02(:),'w^');  
            
            

            
            switch inormalise
                case 1
                    xlabel('( Nd - mean Nd ) / \sigma');
                    ylabel(['( ' y_axis_lab ' - mean ' y_axis_lab ' ) / \sigma']);
                case 2
                    xlabel('( Nd - mean Nd )');
                    ylabel(['( ' y_axis_lab ' - mean ' y_axis_lab '  )']);
                otherwise
                    xlabel('N_d (cm^{-3})');
                    ylabel([y_axis_lab ' (g m^{-2})']);
            end
            
            savename = [y_axis_lab ' vs Nd, ' fileUM{idat_UM}(1:7) ', ' it_title{it_periods} ', dt=' num2str(dt_actual) ', LWP thresh = ' num2str(LWP_thresh), ', M=' num2str(M) ', N=' num2str(N)];
            title(savename);
            
end

return


%% Data for plot set here
dat_modis = time_mean_2D;


units_str_plot = '(m)';
titlenam_driver = [VAR_NAME_STR ' for ' labs_UM(idat_UM).l ' ' units_str_plot];

LAT_val_DRIVER = [-1e9 1e9];
LON_val_DRIVER = [-1e9 1e9]; %Can restrict the plot region with this if set irestrict_domain_DRIVER=1

irestrict_domain_DRIVER=0;

%--- run the file to set up the defaults
        plot_global_maps_defaults
        
irestrict_domain=irestrict_domain_DRIVER; %whether to restrict the domain or not

thresh_LAT = LAT_val_DRIVER;
thresh_LON = LON_val_DRIVER;

%--- set some options for these particular plot loops
set_screening = {'none'};
modis_data_plot = 'Map of 2D data from outside driver script';

iset_min_clim=1;
clim_min=0;
iset_max_clim=1;
clim_max=2000;

isave_plot=1;
iplot_markers=0;



mod_data_type='AMSRE';
gcm_str_select = gcm_str_DRIVER;
%        daynum_timeseries3_UM = [1:length(time)];
%        gcm_time_UTC_UM = [1:length(time)];


ifull_swath=0;
igcm_screen=0;




%--- Apply override flags
ioverride_plotglobal_thresh=1; %Override most of the options (what to plot, etc.)
% iocean_only=1;
ioverride_time_selection=0; %Override the times to include
ioverride_plotglobal_loc=1; %Override the location of the plot window
ioverride_years_time_screen=0; %Override years for screening?
iover_ride_plot_global=1; %overrides inew_figure=1; supress_colorbar=0; i_increase_font_size_map_figures_OFF = 0;
%(all set in plot_global_maps_defaults)
                
%---  Run plot script and save
plot_global_maps
%-------------------------------
if isave_plot==1
    saveas_ps_fig_emf(gcf,[savename],'',0,1,0,'',[],0);
    close(gcf);
end



% General instructions for case 'Generic plot specified outside of script'
%Run plot_global_maps_defaults (might want to change these)
            %Then need to set e.g. P, gcm_Plat2D_CERES, gcm_Plon2D_CERES,
            % gcm_Plat2D_edges_CERES, gcm_Plon2D_edges_CERES],
            % gcm_str, daynum_timeseries3_CERES = 1; gcm_time_UTC_CERES = 1; month_amsre=1; year_amsre=1;
            % mod_data_type='AMSRE';
            % Can set these times to one, or do properly depending on what
            % time screening you want, etc.
            
            
end