function [dnumber, dmac, dnccn_all, dmac_all, dnumber_d, dmass_d, active] = activate_CASIM(fact, dt, cloud_mass, cloud_number, w, rho,  T, p, ...
    aerophys, aerochem, aeroact, dustphys, dustchem, dustliq)

%fact = 0.8; %fraction of activated aerosol (added just for Matlab code)
iopt_act=1;
w_small = 0.1;
ccn_tidy = 0.1e6;  %thresholds.F90:  real(wp) :: ccn_tidy = 0.1e+6
nl_tidy = 1.0e-6; %thresholds.F90:  real(wp) :: nl_tidy = 1.0e-6   % tidy cloud number
iuse_activated_aerosol = false; %my flag 

%Called from condevp subroutine.

%     real(wp), intent(in) :: dt
%     real(wp), intent(in) :: cloud_mass, cloud_number, w, rho, T, p
%     real(wp), intent(out) ::  dnumber %Change in the number of droplets/aerosol from activation
%     real(wp), intent(out) ::  dmac %Change in the mass of activated aerosol (only used when l_process=.true.) - see condevp in condensation.F90 for where these are applied
%     type(aerosol_phys), intent(in) :: aerophys
%     type(aerosol_chem), intent(in) :: aerochem
%     type(aerosol_active), intent(in) :: aeroact
%     type(aerosol_phys), intent(in) :: dustphys
%     type(aerosol_chem), intent(in) :: dustchem
%     type(aerosol_active), intent(in) :: dustliq
%     real(wp), intent(out) :: dnccn_all(:),dmac_all(:) %change in numbers and masses in ccn modes - these are positive, but get subtracted from the aerosol in condevp in condensation.F90
%     real(wp), intent(out) :: active % DPG - add a diagnostic for activated aerosol based on Hamish's branch
%     real(wp), intent(out) :: dnumber_d, dmass_d % change in activated dust number and mass
% %    real(wp) :: active, nccn, Smax, rcrit, nccn_active
%     real(wp) :: nccn, Smax, rcrit, nccn_active % DPG - add a diagnostic for activated aerosol based on Hamish's branch
%     real(wp) :: Nd, rm, sigma, density
% INTEGER, INTENT(in) :: k   % DPG - pass the k index for use with the CloudFrac1D array
%
%     real :: work, dmac_i, diff
%     integer :: imode
%     logical :: l_useactive

%DPG - cloud_mass, cloud_number and activated aerosol values passed in here will be grid-box mean as this is called from
%condevp subroutine.




l_useactive=false;
dmac=0.0;
dnumber_d=0.0;
dmass_d=0.0;
dnumber=0.0;
dmac=0.0;
dmac_all(1:3)=0.0;
dnccn_all(1:3)=0.0;

switch iopt_act   
    case 1
        % activate aerosol*fact
        active=fact*sum(aerophys.N(:));
        dnccn_all(2) = active;
    case 2
        % simple Twomey law Cs^k expressed as
        % a function of w (Rogers and Yau 1989)
        active=0.88*C1.^(2.0/(K1+2.0))*(7.0E-2*(w*100.0).^1.5).^(K1/(K1+2.0))*1.0e6/rho;
    case 3
        % Use scheme of Abdul-Razzak and Ghan
        if (w > w_small & sum(aerophys.N(:)) > ccn_tidy)
            %=============================================================================================
            %           Abdul Razzak Ghan scheme
            %-------------------------------------------------------------------------------------

            % -- Call to activation - replace with somethign, or actually call.
            %      CALL AbdulRazzakGhan2000(w, p, T, aerophys, aerochem, dnccn_all, Smax, aeroact &
            %           , nccn_active, l_useactive)


            Smax=1.1; %Only used for the dust stuff here
            
            Nccn(1) = 0;
            Nccn(2) = aerophys.N(2)*fact;
            Nccn(3) = 0;

            %       REAL(wp), INTENT(OUT) :: smax % peak supersaturation

            %       REAL(wp), INTENT(OUT) :: nccn_active % notional nccn that would be generated by activated aerosol

            %       LOGICAL, INTENT(OUT) :: l_useactive % Do we use consider already activated aerosol

            %       REAL(wp), INTENT(OUT) :: smax % peak supersaturation
            %       LOGICAL, INTENT(OUT) :: l_useactive % Do we use consider already activated aerosol

            
            
            

            %       In the call above dnccn_all, Smax and nccn_active will be outputs. l_useactive will also be set.
            %       This will be set to .false. if the optional active_phys flag is not set in the call to AbdulRazzakGhan2000.
            %       So will be false as called above.
            %       Nccn_active is a single number and dccn_all is an array with an entry for each mode.
            %       Note, that cloud mass and number are not used by AbdulRazzakGhan.

            %SUBROUTINE AbdulRazzakGhan2000(w, p, T, phys, chem, nccn, Smax, active_phys   &
            %     , nccn_active, l_useactive )

            %       REAL(wp), INTENT(IN) :: w % vertical velocity (ms-1)
            %       REAL(wp), INTENT(IN) :: p % pressure (Pa)
            %       REAL(wp), INTENT(IN) :: T % temperature (K)
            %       TYPE(aerosol_phys), INTENT(IN) :: phys
            %       TYPE(aerosol_chem), INTENT(IN) :: chem
            %       REAL(wp), INTENT(OUT) :: Nccn(:) % number of activated aerosol
            % for each mode
            %       REAL(wp), INTENT(OUT) :: smax % peak supersaturation

            %TYPE(aerosol_active), INTENT(IN), OPTIONAL :: active_phys

            %       REAL(wp), INTENT(OUT) :: nccn_active % notional nccn that would be generated by activated aerosol

            %       LOGICAL, INTENT(OUT) :: l_useactive % Do we use consider already activated aerosol

            %       REAL(wp), INTENT(OUT) :: smax % peak supersaturation
            %       LOGICAL, INTENT(OUT) :: l_useactive % Do we use consider already activated aerosol

            active=sum(dnccn_all(:));

            %  Dust.
            if (Smax > 0.02 & ~l_warm)
                % need better model than this. Could do partitioning in the same way as CCN
                dnumber_d=.01*dustphys.N(1);
                dmass_d=dnumber_d*dustphys.M(1)/dustphys.N(1);
            end
        else
            active=0.0;
        end
    case 4
        % Use scheme of Shipway 2015
        % This is a bit clunk and could be harmonized
        nmodes=aero_index.nccn;
        for imode=1:aero_index.nccn;
            bi(imode) =aerochem.vantHoff(imode)*aerochem.epsv(imode)* ...
                aerochem.density(imode)*Mw/(rhow*aerochem.massMole(imode));
            Ndi(imode)=aerophys.N(imode);
            rdi(imode)=aerophys.rd(imode);
            sigmad(imode)=aerophys.sigma(imode);
            betai(imode)=aerochem.beta(imode);
            % only use the mode if there's significant number
            use_mode(imode) = aerophys.N(imode) > Nd_min;
        end

        %Matlab - add call to this if want to use
%         if (any(use_mode) & cloud_number < sum(Ndi))
% 
% 
%             %call solve_nccn_brent(smax0, ...
%             %           w,T,p,alpha_c,ent_fraction, smax, active, nccni)
%             %        dnccn_all(1:aero_index.nccn) = nccni(1:aero_index.nccn);
%         else
%             active=0.0;
%         end
        
    otherwise
        % fixed number
        active=fixed_cloud_number;        
end

switch iopt_act
    case {1,2,3,4}

        %      if ( timestep_number*timestep/3600.0 < time_start_processing ) then
        %         cloud_number = 0.0 %DPG - hack to make activaiton create droplets ignoring the current number of droplets since when re-start processing we want the activated aerosol masses to be re-calculated as though it was the first timestep.
        %      end

        if (active > nl_tidy)
            if (l_useactive) ;
                dnumber=active
            elseif (iuse_activated_aerosol)
                %Just do for cloud (not rain).
                %Use the full number for dccn_all for now (based on
                %replenished/evaporated aerosol). This means that the change in aerosol
                %mass will be calculated as though all of the aerosol was there.
                %But restrict the droplet change
                %(dnumber) to only add droplets (not remove) them.
                %Will change dccn_all accordingly later (as done in next else
                %statement).
                dnumber=max(0.0,(active-cloud_number)); %could alternatively write
                %active - Naero_added_replenish(imode) here since the latter = cloud_number
            else
                dnumber=max(0.0,(active-cloud_number));
                % Rescale number to ensure total removal of aerosol number=creation of cloud number
                % Rescaled according to the fraction of aerosol within each mode that
                % is contributing to active (dccn_all is of size (1:nmodes))
                dnccn_all = dnccn_all*(dnumber/(sum(dnccn_all) + 1e-99));
            end
            % Need to make this consistent with all aerosol_options
            for imode = 1:3  %aero_index.nccn
                Nd=aerophys.N(imode); %if (iuse_activated_aerosol) then these will have
                %been increased to replenish aerosol and rm
                %recalculated. dmac_all contains the changes
                %based on the replenished aerosol - needs to be
                %scaled after mass calc.
                if (Nd > ccn_tidy)
                    rm=aerophys.rd(imode);
                    sigma=aerophys.sigma(imode);
                    density=aerochem.density(imode);
                    
%% Test plot
                    itest_plot=1;
                    if itest_plot==1
                        %Test code for graphs, etc.
                        Nact=[0:1e5:3.8e8];
                        for ii=1:length(Nact)
                            rcritN(ii)=invert_partial_moment_betterapprox(Nact(ii), 0.0, Nd, rm, sigma);
                            dm_act(ii) = (4.0*pi*density/3.0)*(upperpartial_moment_logn(Nd, rm, sigma, 3.0, rcritN(ii)));
                        end

                        figure
                        plot(Nact,rcritN,'bo-'); %set(gca,'yscale','log');
                        xlabel('Number of aerosol activated (m^{-3})');
                        ylabel('Critical radius (m)');
                        figure
                        plot(Nact,dm_act,'bo-');
                        xlabel('Number of aerosol activated (m^{-3})');
                        ylabel('Mass of aerosol activated (kg)');                        
                    end
                        

                    %Find the critical radius (radius down to which we activate) for the number of aerosol that we are
                    %removing from the tail of the distribution.
                    rcrit=invert_partial_moment_betterapprox(dnccn_all(imode), 0.0, Nd, rm, sigma);

                    dmac_all(imode)=(4.0*pi*density/3.0)*(upperpartial_moment_logn(Nd, rm, sigma, 3.0, rcrit));
                    %Think the above calculates the mass of the aerosol in the
                    %distribution from rcrit to infinity. The function calculates the
                    %3rd moment integral - i.e. integral of ( n(r)*r.^3 )

                    if (iuse_activated_aerosol)
                        dmac_all(imode) = dmac_all(imode) - Maero_added_replenish(k,imode);
                        dmac_all(imode) = min(   dmac_all(imode),0.999*(aerophys.M(imode) - Maero_added_replenish(k,imode) )   );  % Don't remove more than 99.9%
                    else
                        dmac_all(imode)=min(dmac_all(imode),0.999*aerophys.M(imode)); % Don't remove more than 99.9%
                        %DPG - this limit to the mass could also introduce
                        %misalignment with the number - should probably remove
                        %all of the number of aerosol if removing all of the
                        %mass and adjust the droplet number too. Might be tricky
                        %to deal with, though - hopefully Abdul would do
                        %something consistent with the number (i.e. remove most
                        %of the number?)
                    end
                    dmac=dmac+dmac_all(imode);
                end
            end
            if (iuse_activated_aerosol)
                % Rescale number to ensure total removal of aerosol number=creation of cloud number
                % Rescaled according to the fraction of aerosol within each mode that
                % is contributing to active (dccn_all is of size (1:nmodes))
                dnccn_all = dnccn_all*(dnumber/(sum(dnccn_all) + 1e-99));
                % Do here instead of at start when replenishing. dnumber has been
                % fixed to number activated minus droplet_number, which will be the
                % same as aero_added_replenish for N.
            end

        end

    otherwise
        % fixed number, so no need to calculate aerosol changes
        dnumber=max(0.0,(active-cloud_number))

end %switch/select

% Convert to rates rather than increments
dmac=dmac/dt;
dmac_all=dmac_all/dt;
dnccn_all=dnccn_all/dt;
dnumber=dnumber/dt;
dnumber_d=dnumber_d/dt;
dmass_d=dmass_d/dt;

%         IF (l_cfrac_casim_diag_scheme) THEN
%         %DPG - if are using cloud scheme then multiply the sources from activation by the cloud fraction
%         %Aerosol is assumed the same in the cloudy and non-cloudy parts and activation does not use
%         %cloud information (so doesn't matter whether we have in-cloud or grid-box averages here)
%         %Activation will give Nd assuming 100% cloud, whereas we want our tendencies to be grid-box averages.
%               dmac      = dmac * LiqCloudFrac1D(k)
%               dmac_all  = dmac_all * LiqCloudFrac1D(k)
%               dnccn_all = dnccn_all * LiqCloudFrac1D(k)
%               dnumber   = dnumber * LiqCloudFrac1D(k) %The number here will be equivalent to an in-cloud value since there no cloud drops are activated out of cloud
%                                                   %So, multiply by the CF to convert to grid-box mean.
%               dnumber_d = dnumber_d * LiqCloudFrac1D(k)   %Dust - this will also need to be scaled according the fraction occupied by cloud
%               dmass_d = dmass_d * LiqCloudFrac1D(k)
%
%
%         end


%
% Calculate the lower bound of integral given
% a complete and upper partial moment
%
% mup = int_x^infinty r^p*n(r)dr
%
% where
%
%    n(r) = N/(r*sqrt(2*pi)*log(sigma)) &
%            *exp(-.5*(log(r/rm)/log(sigma))^2)
%
% rm = median radius
% log(rm) = mean of log(n(r)/N)
% log(sigma) = s.d. of log(n(r)/N)
%
% This uses an approximation 26.2.23 from A&S
    function f_out = invert_partial_moment_betterapprox(mup, p, N, rm, sigma)
%         real(wp), intent(in) :: mup, rm, sigma, N, p % pth moment
%         real(wp) :: invert_partial_moment_betterapprox
% 
%         real(wp) :: frac, x
%         real(wp) :: small_frac=1e-6

small_frac=1e-6;

%        if (mup==0.0)
        if (mup<1e-40)            
%            frac=epsilon(x); %epsilon(x) returns the smallest number E of the same kind as X such that 1 + E > 1
            frac=1e-40;
        else
            frac = mup/(N*rm.^p).*exp(-.5.*p.*p.*log(sigma).*log(sigma));
        end

%            if (frac>=1.0 - 1e-40); frac=.999; end
            if (frac>=1.0 - 1e-40); frac=.999; end            
                if (frac > small_frac)
                    x=normal_quantile(frac);
                    f_out=rm*exp(x*log(sigma)+p*log(sigma)*log(sigma));
                else
                    f_out=999; %0.0; %***MAJOR BUG here - rcrit should be infinity (or v. large) if have no particles activating!
%                    f_out = 0.0;
                end



  %
  % Calculate the upper partial moment of a
  % lognormal distribution
  %
  % int_rcrit^infinty r^p*n(r)dr
  %
  % where
  %
  %    n(r) = N/(r*sqrt(2*pi)*log(sigma)) &
  %            *exp(-.5*(log(r/rm)/log(sigma))^2)
  %
  % rm = median radius
  % log(rm) = mean of log(n(r)/N)
  % log(sigma) = s.d. of log(n(r)/N)
  %
  function f_out = upperpartial_moment_logn(N, rm, sigma, p, rcrit)
    %(Presumably) returns the integral of n(r)r^p between rcrit and infinity
    %So, for p=3 this can be used to calculate the volume and mass of the
    %aerosol size distribution. For a lognormal dist with N total aerosol and a
    %median radius of rm and width sigma.
%     real(wp), intent(in) :: N, rm, sigma
%     real(wp), intent(in) :: p % calculate pth moment
%     real(wp), intent(in) :: rcrit % lower threshold for partial moment
%     real(wp) :: upperpartial_moment_logn

%    if (rcrit==0.0) %Means we are activating all of the aerosol.
    if (rcrit<1e-40) %Means we are activating all of the aerosol.
      f_out=moment_logn(N, rm, sigma, p);
    else
      f_out=N*rm^p*exp(.5*p*p*log(sigma)^2)     ...
           * .5*erfc((log(rcrit/rm)/log(sigma) - p*log(sigma))/sqrt(2.0));
    end

    
      %
  % Calculate the moments of a lognormal distribution
  %
  % int_0^infinty r^p*n(r)dr
  %
  % where
  %
  %    n(r) = N/(r*sqrt(2*pi)*log(sigma)) &
  %            *exp(-.5*(log(r/rm)/log(sigma))^2)
  %
  % rm = median radius
  % log(rm) = mean of log(n(r)/N)
  % log(sigma) = s.d. of log(n(r)/N)
  %
  function f_out = moment_logn(N, rm, sigma, p)
%     real(wp), intent(in) :: N, rm, sigma
%     real(wp), intent(in) :: p % calculate pth moment
%     real(wp) :: moment_logn

    f_out=N*rm.^p*exp(.5*p*p*log(sigma).^2);


   % This uses an approximation 26.2.23 from A&S
  function f_out = normal_quantile(p)
%     real(wp), intent(in) :: p
%     real(wp) :: normal_quantile
% 
%     real(wp) :: pp, t,x
%     real(wp) :: c0,c1,c2,d1,d2,d3

    c0=2.515517;
    c1=0.802853;
    c2=0.010328;
    d1=1.432788;
    d2=0.189269;
    d3=0.001308;

    pp=p;

    if (p<=1e-40) 
%      x=huge(x)
      x=1e99;
    elseif (p >=1.0 - 1e-40)
%      x=-huge(x)
      x = - 1e99;      
    else
      if (p>0.5); pp=1.0-p; end
      t=sqrt(log(1.0/(pp*pp)));
      x=t-(c0+c1*t+c2*t*t)/(1.0+d1*t+d2*t*t+d3*t*t*t);
      if (p>0.5); x=-x; end
        end
    f_out=x;

              
                